{"version":3,"sources":["jquery.ui.widget.js","jquery.iframe-transport.js","jquery.fileupload.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"fileupload.js","sourcesContent":["/*! jQuery UI - v1.11.1+CommonJS - 2014-09-17\r\n* http://jqueryui.com\r\n* Includes: widget.js\r\n* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */\r\n\r\n(function( factory ) {\r\n\tif ( typeof define === \"function\" && define.amd ) {\r\n\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine([ \"jquery\" ], factory );\r\n\r\n\t} else if (typeof exports === \"object\") {\r\n\t\t// Node/CommonJS:\r\n\t\tfactory(require(\"jquery\"));\r\n\r\n\t} else {\r\n\r\n\t\t// Browser globals\r\n\t\tfactory( jQuery );\r\n\t}\r\n}(function( $ ) {\r\n/*!\r\n * jQuery UI Widget 1.11.1\r\n * http://jqueryui.com\r\n *\r\n * Copyright 2014 jQuery Foundation and other contributors\r\n * Released under the MIT license.\r\n * http://jquery.org/license\r\n *\r\n * http://api.jqueryui.com/jQuery.widget/\r\n */\r\n\r\n\r\nvar widget_uuid = 0,\r\n\twidget_slice = Array.prototype.slice;\r\n\r\n$.cleanData = (function( orig ) {\r\n\treturn function( elems ) {\r\n\t\tvar events, elem, i;\r\n\t\tfor ( i = 0; (elem = elems[i]) != null; i++ ) {\r\n\t\t\ttry {\r\n\r\n\t\t\t\t// Only trigger remove when necessary to save time\r\n\t\t\t\tevents = $._data( elem, \"events\" );\r\n\t\t\t\tif ( events && events.remove ) {\r\n\t\t\t\t\t$( elem ).triggerHandler( \"remove\" );\r\n\t\t\t\t}\r\n\r\n\t\t\t// http://bugs.jquery.com/ticket/8235\r\n\t\t\t} catch( e ) {}\r\n\t\t}\r\n\t\torig( elems );\r\n\t};\r\n})( $.cleanData );\r\n\r\n$.widget = function( name, base, prototype ) {\r\n\tvar fullName, existingConstructor, constructor, basePrototype,\r\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\r\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\r\n\t\tproxiedPrototype = {},\r\n\t\tnamespace = name.split( \".\" )[ 0 ];\r\n\r\n\tname = name.split( \".\" )[ 1 ];\r\n\tfullName = namespace + \"-\" + name;\r\n\r\n\tif ( !prototype ) {\r\n\t\tprototype = base;\r\n\t\tbase = $.Widget;\r\n\t}\r\n\r\n\t// create selector for plugin\r\n\t$.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\r\n\t\treturn !!$.data( elem, fullName );\r\n\t};\r\n\r\n\t$[ namespace ] = $[ namespace ] || {};\r\n\texistingConstructor = $[ namespace ][ name ];\r\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\r\n\t\t// allow instantiation without \"new\" keyword\r\n\t\tif ( !this._createWidget ) {\r\n\t\t\treturn new constructor( options, element );\r\n\t\t}\r\n\r\n\t\t// allow instantiation without initializing for simple inheritance\r\n\t\t// must use \"new\" keyword (the code above always passes args)\r\n\t\tif ( arguments.length ) {\r\n\t\t\tthis._createWidget( options, element );\r\n\t\t}\r\n\t};\r\n\t// extend with the existing constructor to carry over any static properties\r\n\t$.extend( constructor, existingConstructor, {\r\n\t\tversion: prototype.version,\r\n\t\t// copy the object used to create the prototype in case we need to\r\n\t\t// redefine the widget later\r\n\t\t_proto: $.extend( {}, prototype ),\r\n\t\t// track widgets that inherit from this widget in case this widget is\r\n\t\t// redefined after a widget inherits from it\r\n\t\t_childConstructors: []\r\n\t});\r\n\r\n\tbasePrototype = new base();\r\n\t// we need to make the options hash a property directly on the new instance\r\n\t// otherwise we'll modify the options hash on the prototype that we're\r\n\t// inheriting from\r\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\r\n\t$.each( prototype, function( prop, value ) {\r\n\t\tif ( !$.isFunction( value ) ) {\r\n\t\t\tproxiedPrototype[ prop ] = value;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tproxiedPrototype[ prop ] = (function() {\r\n\t\t\tvar _super = function() {\r\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\r\n\t\t\t\t},\r\n\t\t\t\t_superApply = function( args ) {\r\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\r\n\t\t\t\t};\r\n\t\t\treturn function() {\r\n\t\t\t\tvar __super = this._super,\r\n\t\t\t\t\t__superApply = this._superApply,\r\n\t\t\t\t\treturnValue;\r\n\r\n\t\t\t\tthis._super = _super;\r\n\t\t\t\tthis._superApply = _superApply;\r\n\r\n\t\t\t\treturnValue = value.apply( this, arguments );\r\n\r\n\t\t\t\tthis._super = __super;\r\n\t\t\t\tthis._superApply = __superApply;\r\n\r\n\t\t\t\treturn returnValue;\r\n\t\t\t};\r\n\t\t})();\r\n\t});\r\n\tconstructor.prototype = $.widget.extend( basePrototype, {\r\n\t\t// TODO: remove support for widgetEventPrefix\r\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\r\n\t\t// don't prefix for widgets that aren't DOM-based\r\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\r\n\t}, proxiedPrototype, {\r\n\t\tconstructor: constructor,\r\n\t\tnamespace: namespace,\r\n\t\twidgetName: name,\r\n\t\twidgetFullName: fullName\r\n\t});\r\n\r\n\t// If this widget is being redefined then we need to find all widgets that\r\n\t// are inheriting from it and redefine all of them so that they inherit from\r\n\t// the new version of this widget. We're essentially trying to replace one\r\n\t// level in the prototype chain.\r\n\tif ( existingConstructor ) {\r\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\r\n\t\t\tvar childPrototype = child.prototype;\r\n\r\n\t\t\t// redefine the child widget using the same prototype that was\r\n\t\t\t// originally used, but inherit from the new version of the base\r\n\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\r\n\t\t});\r\n\t\t// remove the list of existing child constructors from the old constructor\r\n\t\t// so the old child constructors can be garbage collected\r\n\t\tdelete existingConstructor._childConstructors;\r\n\t} else {\r\n\t\tbase._childConstructors.push( constructor );\r\n\t}\r\n\r\n\t$.widget.bridge( name, constructor );\r\n\r\n\treturn constructor;\r\n};\r\n\r\n$.widget.extend = function( target ) {\r\n\tvar input = widget_slice.call( arguments, 1 ),\r\n\t\tinputIndex = 0,\r\n\t\tinputLength = input.length,\r\n\t\tkey,\r\n\t\tvalue;\r\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\r\n\t\tfor ( key in input[ inputIndex ] ) {\r\n\t\t\tvalue = input[ inputIndex ][ key ];\r\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\r\n\t\t\t\t// Clone objects\r\n\t\t\t\tif ( $.isPlainObject( value ) ) {\r\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\r\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\r\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\r\n\t\t\t\t\t\t$.widget.extend( {}, value );\r\n\t\t\t\t// Copy everything else by reference\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget[ key ] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn target;\r\n};\r\n\r\n$.widget.bridge = function( name, object ) {\r\n\tvar fullName = object.prototype.widgetFullName || name;\r\n\t$.fn[ name ] = function( options ) {\r\n\t\tvar isMethodCall = typeof options === \"string\",\r\n\t\t\targs = widget_slice.call( arguments, 1 ),\r\n\t\t\treturnValue = this;\r\n\r\n\t\t// allow multiple hashes to be passed on init\r\n\t\toptions = !isMethodCall && args.length ?\r\n\t\t\t$.widget.extend.apply( null, [ options ].concat(args) ) :\r\n\t\t\toptions;\r\n\r\n\t\tif ( isMethodCall ) {\r\n\t\t\tthis.each(function() {\r\n\t\t\t\tvar methodValue,\r\n\t\t\t\t\tinstance = $.data( this, fullName );\r\n\t\t\t\tif ( options === \"instance\" ) {\r\n\t\t\t\t\treturnValue = instance;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif ( !instance ) {\r\n\t\t\t\t\treturn $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\r\n\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\r\n\t\t\t\t}\r\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\r\n\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\r\n\t\t\t\t}\r\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\r\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\r\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\r\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\r\n\t\t\t\t\t\tmethodValue;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tthis.each(function() {\r\n\t\t\t\tvar instance = $.data( this, fullName );\r\n\t\t\t\tif ( instance ) {\r\n\t\t\t\t\tinstance.option( options || {} );\r\n\t\t\t\t\tif ( instance._init ) {\r\n\t\t\t\t\t\tinstance._init();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn returnValue;\r\n\t};\r\n};\r\n\r\n$.Widget = function( /* options, element */ ) {};\r\n$.Widget._childConstructors = [];\r\n\r\n$.Widget.prototype = {\r\n\twidgetName: \"widget\",\r\n\twidgetEventPrefix: \"\",\r\n\tdefaultElement: \"<div>\",\r\n\toptions: {\r\n\t\tdisabled: false,\r\n\r\n\t\t// callbacks\r\n\t\tcreate: null\r\n\t},\r\n\t_createWidget: function( options, element ) {\r\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\r\n\t\tthis.element = $( element );\r\n\t\tthis.uuid = widget_uuid++;\r\n\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\r\n\t\tthis.options = $.widget.extend( {},\r\n\t\t\tthis.options,\r\n\t\t\tthis._getCreateOptions(),\r\n\t\t\toptions );\r\n\r\n\t\tthis.bindings = $();\r\n\t\tthis.hoverable = $();\r\n\t\tthis.focusable = $();\r\n\r\n\t\tif ( element !== this ) {\r\n\t\t\t$.data( element, this.widgetFullName, this );\r\n\t\t\tthis._on( true, this.element, {\r\n\t\t\t\tremove: function( event ) {\r\n\t\t\t\t\tif ( event.target === element ) {\r\n\t\t\t\t\t\tthis.destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tthis.document = $( element.style ?\r\n\t\t\t\t// element within the document\r\n\t\t\t\telement.ownerDocument :\r\n\t\t\t\t// element is window or document\r\n\t\t\t\telement.document || element );\r\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\r\n\t\t}\r\n\r\n\t\tthis._create();\r\n\t\tthis._trigger( \"create\", null, this._getCreateEventData() );\r\n\t\tthis._init();\r\n\t},\r\n\t_getCreateOptions: $.noop,\r\n\t_getCreateEventData: $.noop,\r\n\t_create: $.noop,\r\n\t_init: $.noop,\r\n\r\n\tdestroy: function() {\r\n\t\tthis._destroy();\r\n\t\t// we can probably remove the unbind calls in 2.0\r\n\t\t// all event bindings should go through this._on()\r\n\t\tthis.element\r\n\t\t\t.unbind( this.eventNamespace )\r\n\t\t\t.removeData( this.widgetFullName )\r\n\t\t\t// support: jquery <1.6.3\r\n\t\t\t// http://bugs.jquery.com/ticket/9413\r\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\r\n\t\tthis.widget()\r\n\t\t\t.unbind( this.eventNamespace )\r\n\t\t\t.removeAttr( \"aria-disabled\" )\r\n\t\t\t.removeClass(\r\n\t\t\t\tthis.widgetFullName + \"-disabled \" +\r\n\t\t\t\t\"ui-state-disabled\" );\r\n\r\n\t\t// clean up events and states\r\n\t\tthis.bindings.unbind( this.eventNamespace );\r\n\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\r\n\t\tthis.focusable.removeClass( \"ui-state-focus\" );\r\n\t},\r\n\t_destroy: $.noop,\r\n\r\n\twidget: function() {\r\n\t\treturn this.element;\r\n\t},\r\n\r\n\toption: function( key, value ) {\r\n\t\tvar options = key,\r\n\t\t\tparts,\r\n\t\t\tcurOption,\r\n\t\t\ti;\r\n\r\n\t\tif ( arguments.length === 0 ) {\r\n\t\t\t// don't return a reference to the internal hash\r\n\t\t\treturn $.widget.extend( {}, this.options );\r\n\t\t}\r\n\r\n\t\tif ( typeof key === \"string\" ) {\r\n\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\r\n\t\t\toptions = {};\r\n\t\t\tparts = key.split( \".\" );\r\n\t\t\tkey = parts.shift();\r\n\t\t\tif ( parts.length ) {\r\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\r\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\r\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\r\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\r\n\t\t\t\t}\r\n\t\t\t\tkey = parts.pop();\r\n\t\t\t\tif ( arguments.length === 1 ) {\r\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\r\n\t\t\t\t}\r\n\t\t\t\tcurOption[ key ] = value;\r\n\t\t\t} else {\r\n\t\t\t\tif ( arguments.length === 1 ) {\r\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\r\n\t\t\t\t}\r\n\t\t\t\toptions[ key ] = value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._setOptions( options );\r\n\r\n\t\treturn this;\r\n\t},\r\n\t_setOptions: function( options ) {\r\n\t\tvar key;\r\n\r\n\t\tfor ( key in options ) {\r\n\t\t\tthis._setOption( key, options[ key ] );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\t_setOption: function( key, value ) {\r\n\t\tthis.options[ key ] = value;\r\n\r\n\t\tif ( key === \"disabled\" ) {\r\n\t\t\tthis.widget()\r\n\t\t\t\t.toggleClass( this.widgetFullName + \"-disabled\", !!value );\r\n\r\n\t\t\t// If the widget is becoming disabled, then nothing is interactive\r\n\t\t\tif ( value ) {\r\n\t\t\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\r\n\t\t\t\tthis.focusable.removeClass( \"ui-state-focus\" );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tenable: function() {\r\n\t\treturn this._setOptions({ disabled: false });\r\n\t},\r\n\tdisable: function() {\r\n\t\treturn this._setOptions({ disabled: true });\r\n\t},\r\n\r\n\t_on: function( suppressDisabledCheck, element, handlers ) {\r\n\t\tvar delegateElement,\r\n\t\t\tinstance = this;\r\n\r\n\t\t// no suppressDisabledCheck flag, shuffle arguments\r\n\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\r\n\t\t\thandlers = element;\r\n\t\t\telement = suppressDisabledCheck;\r\n\t\t\tsuppressDisabledCheck = false;\r\n\t\t}\r\n\r\n\t\t// no element argument, shuffle and use this.element\r\n\t\tif ( !handlers ) {\r\n\t\t\thandlers = element;\r\n\t\t\telement = this.element;\r\n\t\t\tdelegateElement = this.widget();\r\n\t\t} else {\r\n\t\t\telement = delegateElement = $( element );\r\n\t\t\tthis.bindings = this.bindings.add( element );\r\n\t\t}\r\n\r\n\t\t$.each( handlers, function( event, handler ) {\r\n\t\t\tfunction handlerProxy() {\r\n\t\t\t\t// allow widgets to customize the disabled handling\r\n\t\t\t\t// - disabled as an array instead of boolean\r\n\t\t\t\t// - disabled class as method for disabling individual parts\r\n\t\t\t\tif ( !suppressDisabledCheck &&\r\n\t\t\t\t\t\t( instance.options.disabled === true ||\r\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n\t\t\t\t\t.apply( instance, arguments );\r\n\t\t\t}\r\n\r\n\t\t\t// copy the guid so direct unbinding works\r\n\t\t\tif ( typeof handler !== \"string\" ) {\r\n\t\t\t\thandlerProxy.guid = handler.guid =\r\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\r\n\t\t\t}\r\n\r\n\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ ),\r\n\t\t\t\teventName = match[1] + instance.eventNamespace,\r\n\t\t\t\tselector = match[2];\r\n\t\t\tif ( selector ) {\r\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\r\n\t\t\t} else {\r\n\t\t\t\telement.bind( eventName, handlerProxy );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_off: function( element, eventName ) {\r\n\t\teventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) + this.eventNamespace;\r\n\t\telement.unbind( eventName ).undelegate( eventName );\r\n\t},\r\n\r\n\t_delay: function( handler, delay ) {\r\n\t\tfunction handlerProxy() {\r\n\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n\t\t\t\t.apply( instance, arguments );\r\n\t\t}\r\n\t\tvar instance = this;\r\n\t\treturn setTimeout( handlerProxy, delay || 0 );\r\n\t},\r\n\r\n\t_hoverable: function( element ) {\r\n\t\tthis.hoverable = this.hoverable.add( element );\r\n\t\tthis._on( element, {\r\n\t\t\tmouseenter: function( event ) {\r\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-hover\" );\r\n\t\t\t},\r\n\t\t\tmouseleave: function( event ) {\r\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-hover\" );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_focusable: function( element ) {\r\n\t\tthis.focusable = this.focusable.add( element );\r\n\t\tthis._on( element, {\r\n\t\t\tfocusin: function( event ) {\r\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-focus\" );\r\n\t\t\t},\r\n\t\t\tfocusout: function( event ) {\r\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-focus\" );\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_trigger: function( type, event, data ) {\r\n\t\tvar prop, orig,\r\n\t\t\tcallback = this.options[ type ];\r\n\r\n\t\tdata = data || {};\r\n\t\tevent = $.Event( event );\r\n\t\tevent.type = ( type === this.widgetEventPrefix ?\r\n\t\t\ttype :\r\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\r\n\t\t// the original event may come from any element\r\n\t\t// so we need to reset the target on the new event\r\n\t\tevent.target = this.element[ 0 ];\r\n\r\n\t\t// copy original event properties over to the new event\r\n\t\torig = event.originalEvent;\r\n\t\tif ( orig ) {\r\n\t\t\tfor ( prop in orig ) {\r\n\t\t\t\tif ( !( prop in event ) ) {\r\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.element.trigger( event, data );\r\n\t\treturn !( $.isFunction( callback ) &&\r\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\r\n\t\t\tevent.isDefaultPrevented() );\r\n\t}\r\n};\r\n\r\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\r\n\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\r\n\t\tif ( typeof options === \"string\" ) {\r\n\t\t\toptions = { effect: options };\r\n\t\t}\r\n\t\tvar hasOptions,\r\n\t\t\teffectName = !options ?\r\n\t\t\t\tmethod :\r\n\t\t\t\toptions === true || typeof options === \"number\" ?\r\n\t\t\t\t\tdefaultEffect :\r\n\t\t\t\t\toptions.effect || defaultEffect;\r\n\t\toptions = options || {};\r\n\t\tif ( typeof options === \"number\" ) {\r\n\t\t\toptions = { duration: options };\r\n\t\t}\r\n\t\thasOptions = !$.isEmptyObject( options );\r\n\t\toptions.complete = callback;\r\n\t\tif ( options.delay ) {\r\n\t\t\telement.delay( options.delay );\r\n\t\t}\r\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\r\n\t\t\telement[ method ]( options );\r\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\r\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\r\n\t\t} else {\r\n\t\t\telement.queue(function( next ) {\r\n\t\t\t\t$( this )[ method ]();\r\n\t\t\t\tif ( callback ) {\r\n\t\t\t\t\tcallback.call( element[ 0 ] );\r\n\t\t\t\t}\r\n\t\t\t\tnext();\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n\r\nvar widget = $.widget;\r\n\r\n\r\n\r\n}));\r\n","/*\r\n * jQuery Iframe Transport Plugin 1.8.3\r\n * https://github.com/blueimp/jQuery-File-Upload\r\n *\r\n * Copyright 2011, Sebastian Tschan\r\n * https://blueimp.net\r\n *\r\n * Licensed under the MIT license:\r\n * http://www.opensource.org/licenses/MIT\r\n */\r\n\r\n/* global define, require, window, document */\r\n\r\n(function (factory) {\r\n    'use strict';\r\n    if (typeof define === 'function' && define.amd) {\r\n        // Register as an anonymous AMD module:\r\n        define(['jquery'], factory);\r\n    } else if (typeof exports === 'object') {\r\n        // Node/CommonJS:\r\n        factory(require('jquery'));\r\n    } else {\r\n        // Browser globals:\r\n        factory(window.jQuery);\r\n    }\r\n}(function ($) {\r\n    'use strict';\r\n\r\n    // Helper variable to create unique names for the transport iframes:\r\n    var counter = 0;\r\n\r\n    // The iframe transport accepts four additional options:\r\n    // options.fileInput: a jQuery collection of file input fields\r\n    // options.paramName: the parameter name for the file form data,\r\n    //  overrides the name property of the file input field(s),\r\n    //  can be a string or an array of strings.\r\n    // options.formData: an array of objects with name and value properties,\r\n    //  equivalent to the return data of .serializeArray(), e.g.:\r\n    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]\r\n    // options.initialIframeSrc: the URL of the initial iframe src,\r\n    //  by default set to \"javascript:false;\"\r\n    $.ajaxTransport('iframe', function (options) {\r\n        if (options.async) {\r\n            // javascript:false as initial iframe src\r\n            // prevents warning popups on HTTPS in IE6:\r\n            /*jshint scripturl: true */\r\n            var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',\r\n            /*jshint scripturl: false */\r\n                form,\r\n                iframe,\r\n                addParamChar;\r\n            return {\r\n                send: function (_, completeCallback) {\r\n                    form = $('<form style=\"display:none;\"></form>');\r\n                    form.attr('accept-charset', options.formAcceptCharset);\r\n                    addParamChar = /\\?/.test(options.url) ? '&' : '?';\r\n                    // XDomainRequest only supports GET and POST:\r\n                    if (options.type === 'DELETE') {\r\n                        options.url = options.url + addParamChar + '_method=DELETE';\r\n                        options.type = 'POST';\r\n                    } else if (options.type === 'PUT') {\r\n                        options.url = options.url + addParamChar + '_method=PUT';\r\n                        options.type = 'POST';\r\n                    } else if (options.type === 'PATCH') {\r\n                        options.url = options.url + addParamChar + '_method=PATCH';\r\n                        options.type = 'POST';\r\n                    }\r\n                    // IE versions below IE8 cannot set the name property of\r\n                    // elements that have already been added to the DOM,\r\n                    // so we set the name along with the iframe HTML markup:\r\n                    counter += 1;\r\n                    iframe = $(\r\n                        '<iframe src=\"' + initialIframeSrc +\r\n                            '\" name=\"iframe-transport-' + counter + '\"></iframe>'\r\n                    ).bind('load', function () {\r\n                        var fileInputClones,\r\n                            paramNames = $.isArray(options.paramName) ?\r\n                                    options.paramName : [options.paramName];\r\n                        iframe\r\n                            .unbind('load')\r\n                            .bind('load', function () {\r\n                                var response;\r\n                                // Wrap in a try/catch block to catch exceptions thrown\r\n                                // when trying to access cross-domain iframe contents:\r\n                                try {\r\n                                    response = iframe.contents();\r\n                                    // Google Chrome and Firefox do not throw an\r\n                                    // exception when calling iframe.contents() on\r\n                                    // cross-domain requests, so we unify the response:\r\n                                    if (!response.length || !response[0].firstChild) {\r\n                                        throw new Error();\r\n                                    }\r\n                                } catch (e) {\r\n                                    response = undefined;\r\n                                }\r\n                                // The complete callback returns the\r\n                                // iframe content document as response object:\r\n                                completeCallback(\r\n                                    200,\r\n                                    'success',\r\n                                    {'iframe': response}\r\n                                );\r\n                                // Fix for IE endless progress bar activity bug\r\n                                // (happens on form submits to iframe targets):\r\n                                $('<iframe src=\"' + initialIframeSrc + '\"></iframe>')\r\n                                    .appendTo(form);\r\n                                window.setTimeout(function () {\r\n                                    // Removing the form in a setTimeout call\r\n                                    // allows Chrome's developer tools to display\r\n                                    // the response result\r\n                                    form.remove();\r\n                                }, 0);\r\n                            });\r\n                        form\r\n                            .prop('target', iframe.prop('name'))\r\n                            .prop('action', options.url)\r\n                            .prop('method', options.type);\r\n                        if (options.formData) {\r\n                            $.each(options.formData, function (index, field) {\r\n                                $('<input type=\"hidden\"/>')\r\n                                    .prop('name', field.name)\r\n                                    .val(field.value)\r\n                                    .appendTo(form);\r\n                            });\r\n                        }\r\n                        if (options.fileInput && options.fileInput.length &&\r\n                                options.type === 'POST') {\r\n                            fileInputClones = options.fileInput.clone();\r\n                            // Insert a clone for each file input field:\r\n                            options.fileInput.after(function (index) {\r\n                                return fileInputClones[index];\r\n                            });\r\n                            if (options.paramName) {\r\n                                options.fileInput.each(function (index) {\r\n                                    $(this).prop(\r\n                                        'name',\r\n                                        paramNames[index] || options.paramName\r\n                                    );\r\n                                });\r\n                            }\r\n                            // Appending the file input fields to the hidden form\r\n                            // removes them from their original location:\r\n                            form\r\n                                .append(options.fileInput)\r\n                                .prop('enctype', 'multipart/form-data')\r\n                                // enctype must be set as encoding for IE:\r\n                                .prop('encoding', 'multipart/form-data');\r\n                            // Remove the HTML5 form attribute from the input(s):\r\n                            options.fileInput.removeAttr('form');\r\n                        }\r\n                        form.submit();\r\n                        // Insert the file input fields at their original location\r\n                        // by replacing the clones with the originals:\r\n                        if (fileInputClones && fileInputClones.length) {\r\n                            options.fileInput.each(function (index, input) {\r\n                                var clone = $(fileInputClones[index]);\r\n                                // Restore the original name and form properties:\r\n                                $(input)\r\n                                    .prop('name', clone.prop('name'))\r\n                                    .attr('form', clone.attr('form'));\r\n                                clone.replaceWith(input);\r\n                            });\r\n                        }\r\n                    });\r\n                    form.append(iframe).appendTo(document.body);\r\n                },\r\n                abort: function () {\r\n                    if (iframe) {\r\n                        // javascript:false as iframe src aborts the request\r\n                        // and prevents warning popups on HTTPS in IE6.\r\n                        // concat is used to avoid the \"Script URL\" JSLint error:\r\n                        iframe\r\n                            .unbind('load')\r\n                            .prop('src', initialIframeSrc);\r\n                    }\r\n                    if (form) {\r\n                        form.remove();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    // The iframe transport returns the iframe content document as response.\r\n    // The following adds converters from iframe to text, json, html, xml\r\n    // and script.\r\n    // Please note that the Content-Type for JSON responses has to be text/plain\r\n    // or text/html, if the browser doesn't include application/json in the\r\n    // Accept header, else IE will show a download dialog.\r\n    // The Content-Type for XML responses on the other hand has to be always\r\n    // application/xml or text/xml, so IE properly parses the XML response.\r\n    // See also\r\n    // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation\r\n    $.ajaxSetup({\r\n        converters: {\r\n            'iframe text': function (iframe) {\r\n                return iframe && $(iframe[0].body).text();\r\n            },\r\n            'iframe json': function (iframe) {\r\n                return iframe && $.parseJSON($(iframe[0].body).text());\r\n            },\r\n            'iframe html': function (iframe) {\r\n                return iframe && $(iframe[0].body).html();\r\n            },\r\n            'iframe xml': function (iframe) {\r\n                var xmlDoc = iframe && iframe[0];\r\n                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :\r\n                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||\r\n                            $(xmlDoc.body).html());\r\n            },\r\n            'iframe script': function (iframe) {\r\n                return iframe && $.globalEval($(iframe[0].body).text());\r\n            }\r\n        }\r\n    });\r\n\r\n}));\r\n","/*\r\n * jQuery File Upload Plugin 5.42.3\r\n * https://github.com/blueimp/jQuery-File-Upload\r\n *\r\n * Copyright 2010, Sebastian Tschan\r\n * https://blueimp.net\r\n *\r\n * Licensed under the MIT license:\r\n * http://www.opensource.org/licenses/MIT\r\n */\r\n\r\n/* jshint nomen:false */\r\n/* global define, require, window, document, location, Blob, FormData */\r\n\r\n(function (factory) {\r\n    'use strict';\r\n    if (typeof define === 'function' && define.amd) {\r\n        // Register as an anonymous AMD module:\r\n        define([\r\n            'jquery',\r\n            'jquery.ui.widget'\r\n        ], factory);\r\n    } else if (typeof exports === 'object') {\r\n        // Node/CommonJS:\r\n        factory(\r\n            require('jquery'),\r\n            require('./vendor/jquery.ui.widget')\r\n        );\r\n    } else {\r\n        // Browser globals:\r\n        factory(window.jQuery);\r\n    }\r\n}(function ($) {\r\n    'use strict';\r\n\r\n    // Detect file input support, based on\r\n    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/\r\n    $.support.fileInput = !(new RegExp(\r\n        // Handle devices which give false positives for the feature detection:\r\n        '(Android (1\\\\.[0156]|2\\\\.[01]))' +\r\n            '|(Windows Phone (OS 7|8\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +\r\n            '|(w(eb)?OSBrowser)|(webOS)' +\r\n            '|(Kindle/(1\\\\.0|2\\\\.[05]|3\\\\.0))'\r\n    ).test(window.navigator.userAgent) ||\r\n        // Feature detection for all other devices:\r\n        $('<input type=\"file\">').prop('disabled'));\r\n\r\n    // The FileReader API is not actually used, but works as feature detection,\r\n    // as some Safari versions (5?) support XHR file uploads via the FormData API,\r\n    // but not non-multipart XHR file uploads.\r\n    // window.XMLHttpRequestUpload is not available on IE10, so we check for\r\n    // window.ProgressEvent instead to detect XHR2 file upload capability:\r\n    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\r\n    $.support.xhrFormDataFileUpload = !!window.FormData;\r\n\r\n    // Detect support for Blob slicing (required for chunked uploads):\r\n    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||\r\n        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\r\n\r\n    // Helper function to create drag handlers for dragover/dragenter/dragleave:\r\n    function getDragHandler(type) {\r\n        var isDragOver = type === 'dragover';\r\n        return function (e) {\r\n            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\r\n            var dataTransfer = e.dataTransfer;\r\n            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&\r\n                    this._trigger(\r\n                        type,\r\n                        $.Event(type, {delegatedEvent: e})\r\n                    ) !== false) {\r\n                e.preventDefault();\r\n                if (isDragOver) {\r\n                    dataTransfer.dropEffect = 'copy';\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    // The fileupload widget listens for change events on file input fields defined\r\n    // via fileInput setting and paste or drop events of the given dropZone.\r\n    // In addition to the default jQuery Widget methods, the fileupload widget\r\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\r\n    // the fileupload API.\r\n    // By default, files added via file input selection, paste, drag & drop or\r\n    // \"add\" method are uploaded immediately, but it is possible to override\r\n    // the \"add\" callback option to queue file uploads.\r\n    $.widget('blueimp.fileupload', {\r\n\r\n        options: {\r\n            // The drop target element(s), by the default the complete document.\r\n            // Set to null to disable drag & drop support:\r\n            dropZone: $(document),\r\n            // The paste target element(s), by the default undefined.\r\n            // Set to a DOM node or jQuery object to enable file pasting:\r\n            pasteZone: undefined,\r\n            // The file input field(s), that are listened to for change events.\r\n            // If undefined, it is set to the file input fields inside\r\n            // of the widget element on plugin initialization.\r\n            // Set to null to disable the change listener.\r\n            fileInput: undefined,\r\n            // By default, the file input field is replaced with a clone after\r\n            // each input field change event. This is required for iframe transport\r\n            // queues and allows change events to be fired for the same file\r\n            // selection, but can be disabled by setting the following option to false:\r\n            replaceFileInput: true,\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // Set the following option to true to force iframe transport uploads:\r\n            forceIframeTransport: false,\r\n            // Set the following option to the location of a redirect url on the\r\n            // origin server, for cross-domain iframe transport uploads:\r\n            redirect: undefined,\r\n            // The parameter name for the redirect url, sent as part of the form\r\n            // data and set to 'redirect' if this option is empty:\r\n            redirectParamName: undefined,\r\n            // Set the following option to the location of a postMessage window,\r\n            // to enable postMessage transport uploads:\r\n            postMessage: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function (message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    $.each(context, function (key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function (form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function (e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function () {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false,\r\n            timeout: 0\r\n        },\r\n\r\n        // A list of options that require reinitializing event listeners and/or\r\n        // special initialization code:\r\n        _specialOptions: [\r\n            'fileInput',\r\n            'dropZone',\r\n            'pasteZone',\r\n            'multipart',\r\n            'forceIframeTransport'\r\n        ],\r\n\r\n        _blobSlice: $.support.blobSlice && function () {\r\n            var slice = this.slice || this.webkitSlice || this.mozSlice;\r\n            return slice.apply(this, arguments);\r\n        },\r\n\r\n        _BitrateTimer: function () {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function (now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        },\r\n\r\n        _isXHRUpload: function (options) {\r\n            return !options.forceIframeTransport &&\r\n                ((!options.multipart && $.support.xhrFileUpload) ||\r\n                $.support.xhrFormDataFileUpload);\r\n        },\r\n\r\n        _getFormData: function (options) {\r\n            var formData;\r\n            if ($.type(options.formData) === 'function') {\r\n                return options.formData(options.form);\r\n            }\r\n            if ($.isArray(options.formData)) {\r\n                return options.formData;\r\n            }\r\n            if ($.type(options.formData) === 'object') {\r\n                formData = [];\r\n                $.each(options.formData, function (name, value) {\r\n                    formData.push({name: name, value: value});\r\n                });\r\n                return formData;\r\n            }\r\n            return [];\r\n        },\r\n\r\n        _getTotal: function (files) {\r\n            var total = 0;\r\n            $.each(files, function (index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        },\r\n\r\n        _initProgressObject: function (obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                $.extend(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        },\r\n\r\n        _initResponseObject: function (obj) {\r\n            var prop;\r\n            if (obj._response) {\r\n                for (prop in obj._response) {\r\n                    if (obj._response.hasOwnProperty(prop)) {\r\n                        delete obj._response[prop];\r\n                    }\r\n                }\r\n            } else {\r\n                obj._response = {};\r\n            }\r\n        },\r\n\r\n        _onProgress: function (e, data) {\r\n            if (e.lengthComputable) {\r\n                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),\r\n                    loaded;\r\n                if (data._time && data.progressInterval &&\r\n                        (now - data._time < data.progressInterval) &&\r\n                        e.loaded !== e.total) {\r\n                    return;\r\n                }\r\n                data._time = now;\r\n                loaded = Math.floor(\r\n                    e.loaded / e.total * (data.chunkSize || data._progress.total)\r\n                ) + (data.uploadedBytes || 0);\r\n                // Add the difference from the previously loaded state\r\n                // to the global loaded counter:\r\n                this._progress.loaded += (loaded - data._progress.loaded);\r\n                this._progress.bitrate = this._bitrateTimer.getBitrate(\r\n                    now,\r\n                    this._progress.loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                data._progress.loaded = data.loaded = loaded;\r\n                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\r\n                    now,\r\n                    loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                // Trigger a custom progress event with a total data property set\r\n                // to the file size(s) of the current upload and a loaded data\r\n                // property calculated accordingly:\r\n                this._trigger(\r\n                    'progress',\r\n                    $.Event('progress', {delegatedEvent: e}),\r\n                    data\r\n                );\r\n                // Trigger a global progress event for all current file uploads,\r\n                // including ajax calls queued for sequential file uploads:\r\n                this._trigger(\r\n                    'progressall',\r\n                    $.Event('progressall', {delegatedEvent: e}),\r\n                    this._progress\r\n                );\r\n            }\r\n        },\r\n\r\n        _initProgressListener: function (options) {\r\n            var that = this,\r\n                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\r\n            // Accesss to the native XHR object is required to add event listeners\r\n            // for the upload progress event:\r\n            if (xhr.upload) {\r\n                $(xhr.upload).bind('progress', function (e) {\r\n                    var oe = e.originalEvent;\r\n                    // Make sure the progress event properties get copied over:\r\n                    e.lengthComputable = oe.lengthComputable;\r\n                    e.loaded = oe.loaded;\r\n                    e.total = oe.total;\r\n                    that._onProgress(e, options);\r\n                });\r\n                options.xhr = function () {\r\n                    return xhr;\r\n                };\r\n            }\r\n        },\r\n\r\n        _isInstanceOf: function (type, obj) {\r\n            // Cross-frame instanceof check\r\n            return Object.prototype.toString.call(obj) === '[object ' + type + ']';\r\n        },\r\n\r\n        _initXHRData: function (options) {\r\n            var that = this,\r\n                formData,\r\n                file = options.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = options.multipart || !$.support.xhrFileUpload,\r\n                paramName = $.type(options.paramName) === 'array' ?\r\n                    options.paramName[0] : options.paramName;\r\n            options.headers = $.extend({}, options.headers);\r\n            if (options.contentRange) {\r\n                options.headers['Content-Range'] = options.contentRange;\r\n            }\r\n            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\r\n                options.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n            }\r\n            if (!multipart) {\r\n                options.contentType = file.type || 'application/octet-stream';\r\n                options.data = options.blob || file;\r\n            } else if ($.support.xhrFormDataFileUpload) {\r\n                if (options.postMessage) {\r\n                    // window.postMessage does not allow sending FormData\r\n                    // objects, so we just add the File/Blob objects to\r\n                    // the formData array and let the postMessage window\r\n                    // create the FormData object out of this array:\r\n                    formData = this._getFormData(options);\r\n                    if (options.blob) {\r\n                        formData.push({\r\n                            name: paramName,\r\n                            value: options.blob\r\n                        });\r\n                    } else {\r\n                        $.each(options.files, function (index, file) {\r\n                            formData.push({\r\n                                name: ($.type(options.paramName) === 'array' &&\r\n                                    options.paramName[index]) || paramName,\r\n                                value: file\r\n                            });\r\n                        });\r\n                    }\r\n                } else {\r\n                    if (that._isInstanceOf('FormData', options.formData)) {\r\n                        formData = options.formData;\r\n                    } else {\r\n                        formData = new FormData();\r\n                        $.each(this._getFormData(options), function (index, field) {\r\n                            formData.append(field.name, field.value);\r\n                        });\r\n                    }\r\n                    if (options.blob) {\r\n                        formData.append(paramName, options.blob, file.name);\r\n                    } else {\r\n                        $.each(options.files, function (index, file) {\r\n                            // This check allows the tests to run with\r\n                            // dummy objects:\r\n                            if (that._isInstanceOf('File', file) ||\r\n                                    that._isInstanceOf('Blob', file)) {\r\n                                formData.append(\r\n                                    ($.type(options.paramName) === 'array' &&\r\n                                        options.paramName[index]) || paramName,\r\n                                    file,\r\n                                    file.uploadName || file.name\r\n                                );\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                options.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            options.blob = null;\r\n        },\r\n\r\n        _initIframeSettings: function (options) {\r\n            var targetHost = $('<a></a>').prop('href', options.url).prop('host');\r\n            // Setting the dataType to iframe enables the iframe transport:\r\n            options.dataType = 'iframe ' + (options.dataType || '');\r\n            // The iframe transport accepts a serialized array as form data:\r\n            options.formData = this._getFormData(options);\r\n            // Add redirect url to form data on cross-domain uploads:\r\n            if (options.redirect && targetHost && targetHost !== location.host) {\r\n                options.formData.push({\r\n                    name: options.redirectParamName || 'redirect',\r\n                    value: options.redirect\r\n                });\r\n            }\r\n        },\r\n\r\n        _initDataSettings: function (options) {\r\n            if (this._isXHRUpload(options)) {\r\n                if (!this._chunkedUpload(options, true)) {\r\n                    if (!options.data) {\r\n                        this._initXHRData(options);\r\n                    }\r\n                    this._initProgressListener(options);\r\n                }\r\n                if (options.postMessage) {\r\n                    // Setting the dataType to postmessage enables the\r\n                    // postMessage transport:\r\n                    options.dataType = 'postmessage ' + (options.dataType || '');\r\n                }\r\n            } else {\r\n                this._initIframeSettings(options);\r\n            }\r\n        },\r\n\r\n        _getParamName: function (options) {\r\n            var fileInput = $(options.fileInput),\r\n                paramName = options.paramName;\r\n            if (!paramName) {\r\n                paramName = [];\r\n                fileInput.each(function () {\r\n                    var input = $(this),\r\n                        name = input.prop('name') || 'files[]',\r\n                        i = (input.prop('files') || [1]).length;\r\n                    while (i) {\r\n                        paramName.push(name);\r\n                        i -= 1;\r\n                    }\r\n                });\r\n                if (!paramName.length) {\r\n                    paramName = [fileInput.prop('name') || 'files[]'];\r\n                }\r\n            } else if (!$.isArray(paramName)) {\r\n                paramName = [paramName];\r\n            }\r\n            return paramName;\r\n        },\r\n\r\n        _initFormSettings: function (options) {\r\n            // Retrieve missing options from the input field and the\r\n            // associated form, if available:\r\n            if (!options.form || !options.form.length) {\r\n                options.form = $(options.fileInput.prop('form'));\r\n                // If the given file input doesn't have an associated form,\r\n                // use the default widget file input's form:\r\n                if (!options.form.length) {\r\n                    options.form = $(this.options.fileInput.prop('form'));\r\n                }\r\n            }\r\n            options.paramName = this._getParamName(options);\r\n            if (!options.url) {\r\n                options.url = options.form.prop('action') || location.href;\r\n            }\r\n            // The HTTP request method must be \"POST\" or \"PUT\":\r\n            options.type = (options.type ||\r\n                ($.type(options.form.prop('method')) === 'string' &&\r\n                    options.form.prop('method')) || ''\r\n                ).toUpperCase();\r\n            if (options.type !== 'POST' && options.type !== 'PUT' &&\r\n                    options.type !== 'PATCH') {\r\n                options.type = 'POST';\r\n            }\r\n            if (!options.formAcceptCharset) {\r\n                options.formAcceptCharset = options.form.attr('accept-charset');\r\n            }\r\n        },\r\n\r\n        _getAJAXSettings: function (data) {\r\n            var options = $.extend({}, this.options, data);\r\n            this._initFormSettings(options);\r\n            this._initDataSettings(options);\r\n            return options;\r\n        },\r\n\r\n        // jQuery 1.6 doesn't provide .state(),\r\n        // while jQuery 1.8+ removed .isRejected() and .isResolved():\r\n        _getDeferredState: function (deferred) {\r\n            if (deferred.state) {\r\n                return deferred.state();\r\n            }\r\n            if (deferred.isResolved()) {\r\n                return 'resolved';\r\n            }\r\n            if (deferred.isRejected()) {\r\n                return 'rejected';\r\n            }\r\n            return 'pending';\r\n        },\r\n\r\n        // Maps jqXHR callbacks to the equivalent\r\n        // methods of the given Promise object:\r\n        _enhancePromise: function (promise) {\r\n            promise.success = promise.done;\r\n            promise.error = promise.fail;\r\n            promise.complete = promise.always;\r\n            return promise;\r\n        },\r\n\r\n        // Creates and returns a Promise object enhanced with\r\n        // the jqXHR methods abort, success, error and complete:\r\n        _getXHRPromise: function (resolveOrReject, context, args) {\r\n            var dfd = $.Deferred(),\r\n                promise = dfd.promise();\r\n            context = context || this.options.context || promise;\r\n            if (resolveOrReject === true) {\r\n                dfd.resolveWith(context, args);\r\n            } else if (resolveOrReject === false) {\r\n                dfd.rejectWith(context, args);\r\n            }\r\n            promise.abort = dfd.promise;\r\n            return this._enhancePromise(promise);\r\n        },\r\n\r\n        // Adds convenience methods to the data callback argument:\r\n        _addConvenienceMethods: function (e, data) {\r\n            var that = this,\r\n                getPromise = function (args) {\r\n                    return $.Deferred().resolveWith(that, args).promise();\r\n                };\r\n            data.process = function (resolveFunc, rejectFunc) {\r\n                if (resolveFunc || rejectFunc) {\r\n                    data._processQueue = this._processQueue =\r\n                        (this._processQueue || getPromise([this])).pipe(\r\n                            function () {\r\n                                if (data.errorThrown) {\r\n                                    return $.Deferred()\r\n                                        .rejectWith(that, [data]).promise();\r\n                                }\r\n                                return getPromise(arguments);\r\n                            }\r\n                        ).pipe(resolveFunc, rejectFunc);\r\n                }\r\n                return this._processQueue || getPromise([this]);\r\n            };\r\n            data.submit = function () {\r\n                if (this.state() !== 'pending') {\r\n                    data.jqXHR = this.jqXHR =\r\n                        (that._trigger(\r\n                            'submit',\r\n                            $.Event('submit', {delegatedEvent: e}),\r\n                            this\r\n                        ) !== false) && that._onSend(e, this);\r\n                }\r\n                return this.jqXHR || that._getXHRPromise();\r\n            };\r\n            data.abort = function () {\r\n                if (this.jqXHR) {\r\n                    return this.jqXHR.abort();\r\n                }\r\n                this.errorThrown = 'abort';\r\n                that._trigger('fail', null, this);\r\n                return that._getXHRPromise(false);\r\n            };\r\n            data.state = function () {\r\n                if (this.jqXHR) {\r\n                    return that._getDeferredState(this.jqXHR);\r\n                }\r\n                if (this._processQueue) {\r\n                    return that._getDeferredState(this._processQueue);\r\n                }\r\n            };\r\n            data.processing = function () {\r\n                return !this.jqXHR && this._processQueue && that\r\n                    ._getDeferredState(this._processQueue) === 'pending';\r\n            };\r\n            data.progress = function () {\r\n                return this._progress;\r\n            };\r\n            data.response = function () {\r\n                return this._response;\r\n            };\r\n        },\r\n\r\n        // Parses the Range header from the server response\r\n        // and returns the uploaded bytes:\r\n        _getUploadedBytes: function (jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                    parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        },\r\n\r\n        // Uploads a file in multiple, sequential requests\r\n        // by splitting the file up in multiple blob chunks.\r\n        // If the second parameter is true, only tests if the file\r\n        // should be uploaded in chunks, but does not invoke any\r\n        // upload requests:\r\n        _chunkedUpload: function (options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = this._blobSlice,\r\n                dfd = $.Deferred(),\r\n                promise = dfd.promise(),\r\n                jqXHR,\r\n                upload;\r\n            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||\r\n                    options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context,\r\n                    [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function () {\r\n                // Clone the options object for each chunk upload:\r\n                var o = $.extend({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                that._initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                that._initProgressListener(o);\r\n                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||\r\n                        that._getXHRPromise(false, o.context))\r\n                    .done(function (result, textStatus, jqXHR) {\r\n                        ub = that._getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            that._onProgress($.Event('progress', {\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            }), o);\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        that._trigger('chunkdone', null, o);\r\n                        that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context,\r\n                                [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function (jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        that._trigger('chunkfail', null, o);\r\n                        that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context,\r\n                            [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            this._enhancePromise(promise);\r\n            promise.abort = function () {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        },\r\n\r\n        _beforeSend: function (e, data) {\r\n            if (this._active === 0) {\r\n                // the start callback is triggered when an upload starts\r\n                // and no other uploads are currently running,\r\n                // equivalent to the global ajaxStart event:\r\n                this._trigger('start');\r\n                // Set timer for global bitrate progress calculation:\r\n                this._bitrateTimer = new this._BitrateTimer();\r\n                // Reset the global progress values:\r\n                this._progress.loaded = this._progress.total = 0;\r\n                this._progress.bitrate = 0;\r\n            }\r\n            // Make sure the container objects for the .response() and\r\n            // .progress() methods on the data object are available\r\n            // and reset to their initial state:\r\n            this._initResponseObject(data);\r\n            this._initProgressObject(data);\r\n            data._progress.loaded = data.loaded = data.uploadedBytes || 0;\r\n            data._progress.total = data.total = this._getTotal(data.files) || 1;\r\n            data._progress.bitrate = data.bitrate = 0;\r\n            this._active += 1;\r\n            // Initialize the global progress values:\r\n            this._progress.loaded += data.loaded;\r\n            this._progress.total += data.total;\r\n        },\r\n\r\n        _onDone: function (result, textStatus, jqXHR, options) {\r\n            var total = options._progress.total,\r\n                response = options._response;\r\n            if (options._progress.loaded < total) {\r\n                // Create a progress event if no final progress event\r\n                // with loaded equaling total has been triggered:\r\n                this._onProgress($.Event('progress', {\r\n                    lengthComputable: true,\r\n                    loaded: total,\r\n                    total: total\r\n                }), options);\r\n            }\r\n            response.result = options.result = result;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            this._trigger('done', null, options);\r\n        },\r\n\r\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\r\n            var response = options._response;\r\n            if (options.recalculateProgress) {\r\n                // Remove the failed (error or abort) file upload from\r\n                // the global progress calculation:\r\n                this._progress.loaded -= options._progress.loaded;\r\n                this._progress.total -= options._progress.total;\r\n            }\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.errorThrown = options.errorThrown = errorThrown;\r\n            this._trigger('fail', null, options);\r\n        },\r\n\r\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\r\n            // jqXHRorResult, textStatus and jqXHRorError are added to the\r\n            // options object via done and fail callbacks\r\n            this._trigger('always', null, options);\r\n        },\r\n\r\n        _onSend: function (e, data) {\r\n            if (!data.submit) {\r\n                this._addConvenienceMethods(e, data);\r\n            }\r\n            var that = this,\r\n                jqXHR,\r\n                aborted,\r\n                slot,\r\n                pipe,\r\n                options = that._getAJAXSettings(data),\r\n                send = function () {\r\n                    that._sending += 1;\r\n                    // Set timer for bitrate progress calculation:\r\n                    options._bitrateTimer = new that._BitrateTimer();\r\n                    jqXHR = jqXHR || (\r\n                        ((aborted || that._trigger(\r\n                            'send',\r\n                            $.Event('send', {delegatedEvent: e}),\r\n                            options\r\n                        ) === false) &&\r\n                        that._getXHRPromise(false, options.context, aborted)) ||\r\n                        that._chunkedUpload(options) || $.ajax(options)\r\n                    ).done(function (result, textStatus, jqXHR) {\r\n                        that._onDone(result, textStatus, jqXHR, options);\r\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\r\n                        that._onFail(jqXHR, textStatus, errorThrown, options);\r\n                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\r\n                        that._onAlways(\r\n                            jqXHRorResult,\r\n                            textStatus,\r\n                            jqXHRorError,\r\n                            options\r\n                        );\r\n                        that._sending -= 1;\r\n                        that._active -= 1;\r\n                        if (options.limitConcurrentUploads &&\r\n                                options.limitConcurrentUploads > that._sending) {\r\n                            // Start the next queued upload,\r\n                            // that has not been aborted:\r\n                            var nextSlot = that._slots.shift();\r\n                            while (nextSlot) {\r\n                                if (that._getDeferredState(nextSlot) === 'pending') {\r\n                                    nextSlot.resolve();\r\n                                    break;\r\n                                }\r\n                                nextSlot = that._slots.shift();\r\n                            }\r\n                        }\r\n                        if (that._active === 0) {\r\n                            // The stop callback is triggered when all uploads have\r\n                            // been completed, equivalent to the global ajaxStop event:\r\n                            that._trigger('stop');\r\n                        }\r\n                    });\r\n                    return jqXHR;\r\n                };\r\n            this._beforeSend(e, options);\r\n            if (this.options.sequentialUploads ||\r\n                    (this.options.limitConcurrentUploads &&\r\n                    this.options.limitConcurrentUploads <= this._sending)) {\r\n                if (this.options.limitConcurrentUploads > 1) {\r\n                    slot = $.Deferred();\r\n                    this._slots.push(slot);\r\n                    pipe = slot.pipe(send);\r\n                } else {\r\n                    this._sequence = this._sequence.pipe(send, send);\r\n                    pipe = this._sequence;\r\n                }\r\n                // Return the piped Promise object, enhanced with an abort method,\r\n                // which is delegated to the jqXHR object of the current upload,\r\n                // and jqXHR callbacks mapped to the equivalent Promise methods:\r\n                pipe.abort = function () {\r\n                    aborted = [undefined, 'abort', 'abort'];\r\n                    if (!jqXHR) {\r\n                        if (slot) {\r\n                            slot.rejectWith(options.context, aborted);\r\n                        }\r\n                        return send();\r\n                    }\r\n                    return jqXHR.abort();\r\n                };\r\n                return this._enhancePromise(pipe);\r\n            }\r\n            return send();\r\n        },\r\n\r\n        _onAdd: function (e, data) {\r\n            var that = this,\r\n                result = true,\r\n                options = $.extend({}, this.options, data),\r\n                files = data.files,\r\n                filesLength = files.length,\r\n                limit = options.limitMultiFileUploads,\r\n                limitSize = options.limitMultiFileUploadSize,\r\n                overhead = options.limitMultiFileUploadSizeOverhead,\r\n                batchSize = 0,\r\n                paramName = this._getParamName(options),\r\n                paramNameSet,\r\n                paramNameSlice,\r\n                fileSet,\r\n                i,\r\n                j = 0;\r\n            if (!filesLength) {\r\n                return false;\r\n            }\r\n            if (limitSize && files[0].size === undefined) {\r\n                limitSize = undefined;\r\n            }\r\n            if (!(options.singleFileUploads || limit || limitSize) ||\r\n                    !this._isXHRUpload(options)) {\r\n                fileSet = [files];\r\n                paramNameSet = [paramName];\r\n            } else if (!(options.singleFileUploads || limitSize) && limit) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i += limit) {\r\n                    fileSet.push(files.slice(i, i + limit));\r\n                    paramNameSlice = paramName.slice(i, i + limit);\r\n                    if (!paramNameSlice.length) {\r\n                        paramNameSlice = paramName;\r\n                    }\r\n                    paramNameSet.push(paramNameSlice);\r\n                }\r\n            } else if (!options.singleFileUploads && limitSize) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i = i + 1) {\r\n                    batchSize += files[i].size + overhead;\r\n                    if (i + 1 === filesLength ||\r\n                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||\r\n                            (limit && i + 1 - j >= limit)) {\r\n                        fileSet.push(files.slice(j, i + 1));\r\n                        paramNameSlice = paramName.slice(j, i + 1);\r\n                        if (!paramNameSlice.length) {\r\n                            paramNameSlice = paramName;\r\n                        }\r\n                        paramNameSet.push(paramNameSlice);\r\n                        j = i + 1;\r\n                        batchSize = 0;\r\n                    }\r\n                }\r\n            } else {\r\n                paramNameSet = paramName;\r\n            }\r\n            data.originalFiles = files;\r\n            $.each(fileSet || files, function (index, element) {\r\n                var newData = $.extend({}, data);\r\n                newData.files = fileSet ? element : [element];\r\n                newData.paramName = paramNameSet[index];\r\n                that._initResponseObject(newData);\r\n                that._initProgressObject(newData);\r\n                that._addConvenienceMethods(e, newData);\r\n                result = that._trigger(\r\n                    'add',\r\n                    $.Event('add', {delegatedEvent: e}),\r\n                    newData\r\n                );\r\n                return result;\r\n            });\r\n            return result;\r\n        },\r\n\r\n        _replaceFileInput: function (data) {\r\n            var input = data.fileInput,\r\n                inputClone = input.clone(true);\r\n            // Add a reference for the new cloned file input to the data argument:\r\n            data.fileInputClone = inputClone;\r\n            $('<form></form>').append(inputClone)[0].reset();\r\n            // Detaching allows to insert the fileInput on another form\r\n            // without loosing the file input value:\r\n            input.after(inputClone).detach();\r\n            // Avoid memory leaks with the detached file input:\r\n            $.cleanData(input.unbind('remove'));\r\n            // Replace the original file input element in the fileInput\r\n            // elements set with the clone, which has been copied including\r\n            // event handlers:\r\n            this.options.fileInput = this.options.fileInput.map(function (i, el) {\r\n                if (el === input[0]) {\r\n                    return inputClone[0];\r\n                }\r\n                return el;\r\n            });\r\n            // If the widget has been initialized on the file input itself,\r\n            // override this.element with the file input clone:\r\n            if (input[0] === this.element[0]) {\r\n                this.element = inputClone;\r\n            }\r\n        },\r\n\r\n        _handleFileTreeEntry: function (entry, path) {\r\n            var that = this,\r\n                dfd = $.Deferred(),\r\n                errorHandler = function (e) {\r\n                    if (e && !e.entry) {\r\n                        e.entry = entry;\r\n                    }\r\n                    // Since $.when returns immediately if one\r\n                    // Deferred is rejected, we use resolve instead.\r\n                    // This allows valid files and invalid items\r\n                    // to be returned together in one set:\r\n                    dfd.resolve([e]);\r\n                },\r\n                successHandler = function (entries) {\r\n                    that._handleFileTreeEntries(\r\n                        entries,\r\n                        path + entry.name + '/'\r\n                    ).done(function (files) {\r\n                        dfd.resolve(files);\r\n                    }).fail(errorHandler);\r\n                },\r\n                readEntries = function () {\r\n                    dirReader.readEntries(function (results) {\r\n                        if (!results.length) {\r\n                            successHandler(entries);\r\n                        } else {\r\n                            entries = entries.concat(results);\r\n                            readEntries();\r\n                        }\r\n                    }, errorHandler);\r\n                },\r\n                dirReader, entries = [];\r\n            path = path || '';\r\n            if (entry.isFile) {\r\n                if (entry._file) {\r\n                    // Workaround for Chrome bug #149735\r\n                    entry._file.relativePath = path;\r\n                    dfd.resolve(entry._file);\r\n                } else {\r\n                    entry.file(function (file) {\r\n                        file.relativePath = path;\r\n                        dfd.resolve(file);\r\n                    }, errorHandler);\r\n                }\r\n            } else if (entry.isDirectory) {\r\n                dirReader = entry.createReader();\r\n                readEntries();\r\n            } else {\r\n                // Return an empy list for file system items\r\n                // other than files or directories:\r\n                dfd.resolve([]);\r\n            }\r\n            return dfd.promise();\r\n        },\r\n\r\n        _handleFileTreeEntries: function (entries, path) {\r\n            var that = this;\r\n            return $.when.apply(\r\n                $,\r\n                $.map(entries, function (entry) {\r\n                    return that._handleFileTreeEntry(entry, path);\r\n                })\r\n            ).pipe(function () {\r\n                return Array.prototype.concat.apply(\r\n                    [],\r\n                    arguments\r\n                );\r\n            });\r\n        },\r\n\r\n        _getDroppedFiles: function (dataTransfer) {\r\n            dataTransfer = dataTransfer || {};\r\n            var items = dataTransfer.items;\r\n            if (items && items.length && (items[0].webkitGetAsEntry ||\r\n                    items[0].getAsEntry)) {\r\n                return this._handleFileTreeEntries(\r\n                    $.map(items, function (item) {\r\n                        var entry;\r\n                        if (item.webkitGetAsEntry) {\r\n                            entry = item.webkitGetAsEntry();\r\n                            if (entry) {\r\n                                // Workaround for Chrome bug #149735:\r\n                                entry._file = item.getAsFile();\r\n                            }\r\n                            return entry;\r\n                        }\r\n                        return item.getAsEntry();\r\n                    })\r\n                );\r\n            }\r\n            return $.Deferred().resolve(\r\n                $.makeArray(dataTransfer.files)\r\n            ).promise();\r\n        },\r\n\r\n        _getSingleFileInputFiles: function (fileInput) {\r\n            fileInput = $(fileInput);\r\n            var entries = fileInput.prop('webkitEntries') ||\r\n                    fileInput.prop('entries'),\r\n                files,\r\n                value;\r\n            if (entries && entries.length) {\r\n                return this._handleFileTreeEntries(entries);\r\n            }\r\n            files = $.makeArray(fileInput.prop('files'));\r\n            if (!files.length) {\r\n                value = fileInput.prop('value');\r\n                if (!value) {\r\n                    return $.Deferred().resolve([]).promise();\r\n                }\r\n                // If the files property is not available, the browser does not\r\n                // support the File API and we add a pseudo File object with\r\n                // the input value as name with path information removed:\r\n                files = [{name: value.replace(/^.*\\\\/, '')}];\r\n            } else if (files[0].name === undefined && files[0].fileName) {\r\n                // File normalization for Safari 4 and Firefox 3:\r\n                $.each(files, function (index, file) {\r\n                    file.name = file.fileName;\r\n                    file.size = file.fileSize;\r\n                });\r\n            }\r\n            return $.Deferred().resolve(files).promise();\r\n        },\r\n\r\n        _getFileInputFiles: function (fileInput) {\r\n            if (!(fileInput instanceof $) || fileInput.length === 1) {\r\n                return this._getSingleFileInputFiles(fileInput);\r\n            }\r\n            return $.when.apply(\r\n                $,\r\n                $.map(fileInput, this._getSingleFileInputFiles)\r\n            ).pipe(function () {\r\n                return Array.prototype.concat.apply(\r\n                    [],\r\n                    arguments\r\n                );\r\n            });\r\n        },\r\n\r\n        _onChange: function (e) {\r\n            var that = this,\r\n                data = {\r\n                    fileInput: $(e.target),\r\n                    form: $(e.target.form)\r\n                };\r\n            this._getFileInputFiles(data.fileInput).always(function (files) {\r\n                data.files = files;\r\n                if (that.options.replaceFileInput) {\r\n                    that._replaceFileInput(data);\r\n                }\r\n                if (that._trigger(\r\n                        'change',\r\n                        $.Event('change', {delegatedEvent: e}),\r\n                        data\r\n                    ) !== false) {\r\n                    that._onAdd(e, data);\r\n                }\r\n            });\r\n        },\r\n\r\n        _onPaste: function (e) {\r\n            var items = e.originalEvent && e.originalEvent.clipboardData &&\r\n                    e.originalEvent.clipboardData.items,\r\n                data = {files: []};\r\n            if (items && items.length) {\r\n                $.each(items, function (index, item) {\r\n                    var file = item.getAsFile && item.getAsFile();\r\n                    if (file) {\r\n                        data.files.push(file);\r\n                    }\r\n                });\r\n                if (this._trigger(\r\n                        'paste',\r\n                        $.Event('paste', {delegatedEvent: e}),\r\n                        data\r\n                    ) !== false) {\r\n                    this._onAdd(e, data);\r\n                }\r\n            }\r\n        },\r\n\r\n        _onDrop: function (e) {\r\n            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\r\n            var that = this,\r\n                dataTransfer = e.dataTransfer,\r\n                data = {};\r\n            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\r\n                e.preventDefault();\r\n                this._getDroppedFiles(dataTransfer).always(function (files) {\r\n                    data.files = files;\r\n                    if (that._trigger(\r\n                            'drop',\r\n                            $.Event('drop', {delegatedEvent: e}),\r\n                            data\r\n                        ) !== false) {\r\n                        that._onAdd(e, data);\r\n                    }\r\n                });\r\n            }\r\n        },\r\n\r\n        _onDragOver: getDragHandler('dragover'),\r\n\r\n        _onDragEnter: getDragHandler('dragenter'),\r\n\r\n        _onDragLeave: getDragHandler('dragleave'),\r\n\r\n        _initEventHandlers: function () {\r\n            if (this._isXHRUpload(this.options)) {\r\n                this._on(this.options.dropZone, {\r\n                    dragover: this._onDragOver,\r\n                    drop: this._onDrop,\r\n                    // event.preventDefault() on dragenter is required for IE10+:\r\n                    dragenter: this._onDragEnter,\r\n                    // dragleave is not required, but added for completeness:\r\n                    dragleave: this._onDragLeave\r\n                });\r\n                this._on(this.options.pasteZone, {\r\n                    paste: this._onPaste\r\n                });\r\n            }\r\n            if ($.support.fileInput) {\r\n                this._on(this.options.fileInput, {\r\n                    change: this._onChange\r\n                });\r\n            }\r\n        },\r\n\r\n        _destroyEventHandlers: function () {\r\n            this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\r\n            this._off(this.options.pasteZone, 'paste');\r\n            this._off(this.options.fileInput, 'change');\r\n        },\r\n\r\n        _setOption: function (key, value) {\r\n            var reinit = $.inArray(key, this._specialOptions) !== -1;\r\n            if (reinit) {\r\n                this._destroyEventHandlers();\r\n            }\r\n            this._super(key, value);\r\n            if (reinit) {\r\n                this._initSpecialOptions();\r\n                this._initEventHandlers();\r\n            }\r\n        },\r\n\r\n        _initSpecialOptions: function () {\r\n            var options = this.options;\r\n            if (options.fileInput === undefined) {\r\n                options.fileInput = this.element.is('input[type=\"file\"]') ?\r\n                        this.element : this.element.find('input[type=\"file\"]');\r\n            } else if (!(options.fileInput instanceof $)) {\r\n                options.fileInput = $(options.fileInput);\r\n            }\r\n            if (!(options.dropZone instanceof $)) {\r\n                options.dropZone = $(options.dropZone);\r\n            }\r\n            if (!(options.pasteZone instanceof $)) {\r\n                options.pasteZone = $(options.pasteZone);\r\n            }\r\n        },\r\n\r\n        _getRegExp: function (str) {\r\n            var parts = str.split('/'),\r\n                modifiers = parts.pop();\r\n            parts.shift();\r\n            return new RegExp(parts.join('/'), modifiers);\r\n        },\r\n\r\n        _isRegExpOption: function (key, value) {\r\n            return key !== 'url' && $.type(value) === 'string' &&\r\n                /^\\/.*\\/[igm]{0,3}$/.test(value);\r\n        },\r\n\r\n        _initDataAttributes: function () {\r\n            var that = this,\r\n                options = this.options,\r\n                data = this.element.data();\r\n            // Initialize options set via HTML5 data-attributes:\r\n            $.each(\r\n                this.element[0].attributes,\r\n                function (index, attr) {\r\n                    var key = attr.name.toLowerCase(),\r\n                        value;\r\n                    if (/^data-/.test(key)) {\r\n                        // Convert hyphen-ated key to camelCase:\r\n                        key = key.slice(5).replace(/-[a-z]/g, function (str) {\r\n                            return str.charAt(1).toUpperCase();\r\n                        });\r\n                        value = data[key];\r\n                        if (that._isRegExpOption(key, value)) {\r\n                            value = that._getRegExp(value);\r\n                        }\r\n                        options[key] = value;\r\n                    }\r\n                }\r\n            );\r\n        },\r\n\r\n        _create: function () {\r\n            this._initDataAttributes();\r\n            this._initSpecialOptions();\r\n            this._slots = [];\r\n            this._sequence = this._getXHRPromise(true);\r\n            this._sending = this._active = 0;\r\n            this._initProgressObject(this);\r\n            this._initEventHandlers();\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the number of active uploads:\r\n        active: function () {\r\n            return this._active;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the widget upload progress.\r\n        // It returns an object with loaded, total and bitrate properties\r\n        // for the running uploads:\r\n        progress: function () {\r\n            return this._progress;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows adding files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files property and can contain additional options:\r\n        // .fileupload('add', {files: filesList});\r\n        add: function (data) {\r\n            var that = this;\r\n            if (!data || this.options.disabled) {\r\n                return;\r\n            }\r\n            if (data.fileInput && !data.files) {\r\n                this._getFileInputFiles(data.fileInput).always(function (files) {\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                });\r\n            } else {\r\n                data.files = $.makeArray(data.files);\r\n                this._onAdd(null, data);\r\n            }\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows sending files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files or fileInput property and can contain additional options:\r\n        // .fileupload('send', {files: filesList});\r\n        // The method returns a Promise object for the file upload call.\r\n        send: function (data) {\r\n            if (data && !this.options.disabled) {\r\n                if (data.fileInput && !data.files) {\r\n                    var that = this,\r\n                        dfd = $.Deferred(),\r\n                        promise = dfd.promise(),\r\n                        jqXHR,\r\n                        aborted;\r\n                    promise.abort = function () {\r\n                        aborted = true;\r\n                        if (jqXHR) {\r\n                            return jqXHR.abort();\r\n                        }\r\n                        dfd.reject(null, 'abort', 'abort');\r\n                        return promise;\r\n                    };\r\n                    this._getFileInputFiles(data.fileInput).always(\r\n                        function (files) {\r\n                            if (aborted) {\r\n                                return;\r\n                            }\r\n                            if (!files.length) {\r\n                                dfd.reject();\r\n                                return;\r\n                            }\r\n                            data.files = files;\r\n                            jqXHR = that._onSend(null, data);\r\n                            jqXHR.then(\r\n                                function (result, textStatus, jqXHR) {\r\n                                    dfd.resolve(result, textStatus, jqXHR);\r\n                                },\r\n                                function (jqXHR, textStatus, errorThrown) {\r\n                                    dfd.reject(jqXHR, textStatus, errorThrown);\r\n                                }\r\n                            );\r\n                        }\r\n                    );\r\n                    return this._enhancePromise(promise);\r\n                }\r\n                data.files = $.makeArray(data.files);\r\n                if (data.files.length) {\r\n                    return this._onSend(null, data);\r\n                }\r\n            }\r\n            return this._getXHRPromise(false, data && data.context);\r\n        }\r\n\r\n    });\r\n\r\n}));\r\n"],"sourceRoot":"/source/"}